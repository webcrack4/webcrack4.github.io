1. Go 语言没有类和继承的概念，通过接口（interface）的概念来实现多态性

2. 函数是 Go 语言中的基本构件

3. Go 语言使用静态类型，作为强类型语言，隐式的类型转换是不被允许的

4. Go 不需要依赖任何其它文件，它只需要一个单独的静态文件，这样你也不会像使用其它语言一样在各种不同版本的依赖文件之间混淆。

5. for的用法
for key, value := range oldMap {
	newMap[key] = value
}

6. Go的 defer 语句用于预设一个函数调用（即推迟执行函数），该函数会在执行 defer 的函数返回之前立即执行。典型的例子就是解锁互斥和关闭文件。

7. append连接两个数组的用法
x := []int{1,2,3}
y := []int{4,5,6}
x = append(x, y...)
fmt.Println(x)
如果没有 ...，它就会由于类型错误而无法编译，因为 y 不是 int 类型的

8. 变量声明的两种写法 
	a := 1 
	var a = 1 
	个人觉得下面这个更好，对于习惯更多编程语言的人来说更可读，而且全局定义只能用下面这种方式
	
9. 反单引号可以跨行，并且引号内的所有内容 都会直接输出，包括转义宇符和空格缩进等。 而双引号则不能换行， 并且会解析转义字符。

10. 函数作为类型可以类比c#委托，用于简化代码

11. Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量？
Golang中Goroutine 可以通过 Channel 进行安全读写共享变量。

12. 无缓冲 Chan 的发送和接收是否同步?
ch := make(chan int)    无缓冲的channel由于没有缓冲发送和接收需要同步。
ch := make(chan int, 2) 有缓冲channel不要求发送和接收操作同步。
channel无缓冲时，发送阻塞直到数据被接收，接收阻塞直到读到数据。
channel有缓冲时，当缓冲满时发送阻塞，当缓冲空时接收阻塞。

13. Golang 中常用的并发模型有三种:
通过channel通知实现并发控制
通过sync包中的WaitGroup实现并发控制
在Go 1.7 以后引进的强大的Context上下文，实现并发控制

14. 通过大小写决定数据类型是公有还是私有

15. 用工厂方法实现结构体的构造函数

16. nil slice 和 空 slice 的处理是不一致.
通常错误的用法，会报数组越界的错误，因为只是声明了slice，却没有给实例化的对象。
var slice []int
slice[1] = 0
此时slice的值是nil，这种情况可以用于需要返回slice的函数，当函数出现异常的时候，保证函数依然会有nil的返回值。
empty slice 是指slice不为nil，但是slice没有值，slice的底层的空间是空的，此时的定义如下：
slice := make([]int,0）
slice := []int{}
当我们查询或者处理一个空的列表的时候，这非常有用，它会告诉我们返回的是一个列表，但是列表内没有任何值。

